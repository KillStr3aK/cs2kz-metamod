#pragma once

#include "kz/kz.h"
#include "sdk/entity/cbasetrigger.h"

/*
	TriggerFix overrides trigger events generated by Valve's code
	to fix cases where players can dodge triggers given the right conditions (edgebug, jumpbugs, perfs).

	Note before proceeding:
	1. Triggers touching events are stored in an array that is filled by vphysics every tick.
	2. When the player starts touching a trigger, StartTouch and Touch are fired.
	3. When the player ends touching a trigger, Touch and EndTouch are fired.
	4. As long as the player is touching a trigger, Touch is fired.
	Due to 2 and 4, this means the first time the player touches a trigger, Touch is fired twice.
	This is different from CS:GO, where Touch can only fire once with StartTouch and it does not fire with EndTouch.

	Modes that use this service need to implement their own trigger touching using TouchTriggersAlongPath and UpdateTriggerTouchList (see VNL).
*/

class KZTriggerService : public KZBaseService
{
public:
	using KZBaseService::KZBaseService;

	virtual void Reset();

	struct TriggerTouchTracker
	{
		CEntityHandle triggerHandle;

		bool operator==(const TriggerTouchTracker &other)
		{
			return triggerHandle == other.triggerHandle;
		}

		// Trigger to player
		bool startedTouch {};
		// Player to trigger.
		bool touchedThisTick {};

		bool CanStartTouch()
		{
			return !startedTouch;
		}

		bool CanTouch()
		{
			return !touchedThisTick;
		}

		bool CanEndTouch()
		{
			// The interaction hasn't even fully started yet.
			// This should never happen but we make the check anyway just to be sure.
			if (!startedTouch)
			{
				META_CONPRINTF("[KZ::Trigger] EndTouch check is called before the start touch interaction even finished!\n");
				return false;
			}
			return true;
		}
	};

private:
	CUtlVector<TriggerTouchTracker> triggerTrackers;
	Vector preTouchOrigin;
	Vector preTouchVelocity;

	bool OnTriggerStartTouchPre(CBaseTrigger *trigger);
	void OnTriggerStartTouchPost(CBaseTrigger *trigger);
	bool OnTriggerTouchPre(CBaseTrigger *trigger);
	void OnTriggerTouchPost(CBaseTrigger *trigger);
	bool OnTriggerEndTouchPre(CBaseTrigger *trigger);
	void OnTriggerEndTouchPost(CBaseTrigger *trigger);

public:
	void OnPhysicsSimulate();
	void OnPhysicsSimulatePost();

	// Hit all triggers from start to end with the specified bounds,
	// and call Touch/StartTouch on triggers that the player is touching.
	void TouchTriggersAlongPath(const Vector &start, const Vector &end, const bbox_t &bounds);

	// Update the list of triggers that the player is touching, and call StartTouch/EndTouch appropriately.
	void UpdateTriggerTouchList();

	// Call Touch() on all currently touched triggers.
	void TouchAll();
	void EndTouchAll();

	// Return true if this interaction is managed by TriggerFix.
	static bool IsManagedByTriggerService(CBaseEntity *toucher, CBaseEntity *touched);

	static bool ShouldTouchOnStartTouch(CBaseTrigger *trigger)
	{
		// TODO: Let mapping API decide whether it is not the case.
		return true;
	}

	static bool ShouldTouchBeforeEndTouch(CBaseTrigger *trigger)
	{
		// TODO: Let mapping API decide whether it is not the case.
		return true;
	}

	TriggerTouchTracker *GetTriggerTracker(CBaseTrigger *trigger);

	void StartTouch(CBaseTrigger *trigger);
	void Touch(CBaseTrigger *trigger, bool silent = false);
	void EndTouch(CBaseTrigger *trigger);

	void UpdatePreTouchData();
	void UpdatePlayerPostTouch();

public:
};

inline bool operator==(const KZTriggerService::TriggerTouchTracker &left, const KZTriggerService::TriggerTouchTracker &right)
{
	return left.triggerHandle == right.triggerHandle;
}
